<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Key-Guardian: BONUS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff9d;
            --neon-yellow: #ffee00;
            --bg-dark: #050510;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: 'Orbitron', sans-serif; user-select: none; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 25px; box-sizing: border-box;}
        
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; text-shadow: 0 0 10px var(--neon-blue); }
        .hud-group { display: flex; flex-direction: column; gap: 5px; }
        
        .score-box { color: white; font-size: 2.5rem; font-weight: 900; }
        .score-label { font-size: 0.9rem; color: var(--neon-blue); opacity: 0.8; letter-spacing: 2px;}
        .lives-box { font-size: 2rem; color: #ff3333; text-shadow: 0 0 15px red; }
        
        /* HIGHSCORE BOX */
        .highscore-box {
            text-align: center;
            color: var(--neon-yellow);
            font-size: 1.2rem;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border: 1px solid var(--neon-yellow);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255, 238, 0, 0.2);
            font-family: 'Roboto Mono', monospace;
        }

        .weapon-badge {
            background: rgba(0, 243, 255, 0.1); border: 2px solid var(--neon-blue);
            padding: 10px 20px; border-radius: 0 15px 0 15px; color: white;
            font-size: 1.2rem; margin-top: 10px; text-align: center;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }

        .combo-meter {
            position: absolute; top: 120px; left: 25px;
            width: 300px; height: 15px; background: rgba(255,255,255,0.1);
            border: 2px solid var(--neon-pink); transform: skewX(-20deg);
            overflow: hidden;
        }
        .combo-fill { height: 100%; background: linear-gradient(90deg, var(--neon-pink), var(--neon-yellow)); width: 0%; transition: width 0.1s; box-shadow: 0 0 20px var(--neon-pink); }
        .combo-text { font-size: 1.8rem; color: var(--neon-yellow); margin-top: 5px; font-weight: 900; opacity: 0; transition: opacity 0.2s; position: absolute; top: 140px; left: 25px; transform: skewX(-10deg); text-shadow: 0 0 10px orange; }

        .center-crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 60px; height: 60px; border: 2px dashed rgba(255,255,255,0.2); border-radius: 50%;
            pointer-events: none; opacity: 0.3;
        }

        /* MENUS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.85); backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; pointer-events: auto;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 { 
            font-size: 5rem; margin: 0; color: white; 
            text-shadow: 0 0 20px var(--neon-blue), 4px 4px 0px var(--neon-pink);
            letter-spacing: 8px; text-transform: uppercase; 
            animation: floatText 3s ease-in-out infinite;
            text-align: center;
        }
        @keyframes floatText { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        h2 { color: var(--neon-green); font-family: 'Roboto Mono', monospace; font-size: 1.4rem; margin-bottom: 40px; text-align: center; }
        
        .btn {
            background: linear-gradient(90deg, var(--neon-pink), #9d00ff);
            border: none; padding: 20px 50px; color: white; font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem; font-weight: bold; cursor: pointer;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: all 0.2s; margin: 15px; text-transform: uppercase;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.4); text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        .btn:hover { transform: scale(1.05) translateY(-2px); box-shadow: 0 0 50px rgba(255, 0, 255, 0.8); filter: brightness(1.2); }
        .btn:active { transform: scale(0.98); }
        
        #upgrade-notif {
            position: absolute; bottom: 25%; left: 50%; transform: translateX(-50%);
            color: var(--neon-yellow); font-size: 4rem; font-weight: 900;
            text-shadow: 0 0 30px orange, 0 0 60px red; 
            opacity: 0; transition: opacity 0.5s, transform 0.5s;
            pointer-events: none; white-space: nowrap; z-index: 15;
        }
        .paused-text { color: white; font-size: 3rem; margin-bottom: 30px; letter-spacing: 5px; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <audio id="bgm" src="bonus.mp3" loop></audio>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-group">
                <span class="score-label">SCORE</span>
                <div class="score-box" id="hud-score">0</div>
                <div class="weapon-badge" id="hud-weapon">LASER MK-1</div>
            </div>

            <div class="hud-group" style="align-items: center;">
                <div class="highscore-box" id="hud-highscores">
                    üèÜ LOADING...
                </div>
            </div>

            <div class="hud-group" style="align-items: flex-end;">
                <span class="score-label">LIVES</span>
                <div class="lives-box" id="hud-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div style="margin-top:10px; color: #888; font-size: 0.8rem;">[ESC] PAUSE</div>
            </div>
        </div>
        
        <div class="combo-meter">
            <div class="combo-fill" id="combo-bar"></div>
        </div>
        <div class="combo-text" id="combo-text">COMBO x2!</div>
        <div class="center-crosshair"></div>
        
        <div id="upgrade-notif">WEAPON UPGRADE!</div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>Neon Type Blaster</h1>
        <h2>Save the Galaxy. One Keystroke at a time.</h2>
        <button class="btn" id="btn-start">DEPLOY SHIP</button>
        <button class="btn" id="btn-return-main" style="background: #444; font-size: 1rem; margin-top: 30px;">Return to Main Game</button>
    </div>

    <div id="pause-screen" class="overlay hidden">
        <div class="paused-text">SYSTEM PAUSED</div>
        <button class="btn" id="btn-resume">RESUME (ESC)</button>
        <button class="btn" id="btn-quit" style="font-size: 1rem; background: #444; padding: 10px 20px;">BACK TO BASE</button>
    </div>

    <div id="gameover-screen" class="overlay hidden">
        <h1 style="color: #ff3333; text-shadow: 0 0 30px red;">MISSION FAILED</h1>
        <h2 id="final-score-disp">Score: 0</h2>
        <button class="btn" id="btn-return">RETURN TO HEDY'S WORLD</button>
    </div>

    <script>
        // --- GALAXY SHADERS ---
        const galaxyVertexShader = `
            uniform float uTime;
            uniform float uSize;
            attribute float aScale;
            attribute float aSpeed;
            varying vec3 vColor;
            void main() {
                vColor = color;
                vec3 pos = position;
                float angle = uTime * aSpeed;
                float x = pos.x * cos(angle) - pos.z * sin(angle);
                float z = pos.x * sin(angle) + pos.z * cos(angle);
                pos.x = x; 
                pos.z = z;
                vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = uSize * aScale * ( 1.0 / - mvPosition.z );
            }
        `;

        const galaxyFragmentShader = `
            varying vec3 vColor;
            void main() {
                float d = distance(gl_PointCoord, vec2(0.5));
                if(d > 0.5) discard;
                float strength = 1.0 - (d * 2.0);
                strength = pow(strength, 2.0);
                gl_FragColor = vec4(vColor, strength);
            }
        `;

        // --- AUDIO SYSTEM ---
        class AudioSynth {
            constructor() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.sfxGain = this.ctx.createGain();
                    this.masterGain.connect(this.ctx.destination);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.gain.value = 1.0;
                    this.sfxGain.gain.value = 0.5;
                    this.enabled = true;
                    this.bgmEl = document.getElementById('bgm');
                } catch(e) {
                    this.enabled = false;
                }
            }

            resume() { if(this.enabled && this.ctx.state === 'suspended') this.ctx.resume(); }

            playTone(freq, type, duration, vol = 1) {
                if(!this.enabled) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                    osc.connect(gain);
                    gain.connect(this.sfxGain);
                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch(e) {}
            }

            playShoot(level) {
                if(level === 1) this.playTone(600, 'square', 0.15, 0.3);
                else if (level === 2) { this.playTone(800, 'square', 0.2, 0.3); setTimeout(()=>this.playTone(800, 'square', 0.2, 0.3), 80); }
                else { this.playTone(200, 'sawtooth', 0.3, 0.5); this.playTone(1500, 'sine', 0.3, 0.3); }
            }

            playMassiveExplosion() {
                this.playTone(60, 'sawtooth', 0.8);
                this.playTone(40, 'square', 0.8);
                setTimeout(()=>this.playTone(800, 'sawtooth', 0.2), 50);
            }

            playLifeLost() {
                this.playTone(300, 'sawtooth', 0.3, 0.5);
                setTimeout(() => this.playTone(150, 'sawtooth', 0.4, 0.5), 150);
            }

            playPowerUp() {
                this.playTone(440, 'sine', 0.6, 0.5);
                setTimeout(()=>this.playTone(880, 'sine', 0.6, 0.5), 200);
            }

            startMusic() { if(this.bgmEl) { this.bgmEl.volume = 0.5; this.bgmEl.play().catch(e=>{}); } }
            stopMusic() { if(this.bgmEl) { this.bgmEl.pause(); this.bgmEl.currentTime = 0; } }
        }

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.audio = new AudioSynth();
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050510, 0.02);
                
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 3, 25);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(10, 20, 10);
                this.scene.add(dirLight);
                
                this.state = 'MENU';
                this.score = 0;
                this.lives = 3;
                this.combo = 0;
                this.weaponLevel = 1;
                this.enemies = [];
                this.particles = [];
                this.shockwaves = []; 
                this.clock = new THREE.Clock();
                this.shakeIntensity = 0; 
                this.spawnRate = 2000;
                this.lastSpawn = 0; 
                this.gameSpeed = 25; 
                this.hits = 0; 
                
                this.galaxy = null;
                this.galaxyMaterial = null;

                this.currentUser = localStorage.getItem('tastenZauberUser') || 'Hedy';
                const storedKeys = localStorage.getItem('tastenZauber_bonusKeys');
                if (storedKeys) {
                    const raw = storedKeys.toUpperCase().replace(/SHIFT/g, '').replace(/[^A-Z0-9√Ñ√ñ√ú]/g, '');
                    this.allowedKeys = raw.length > 0 ? raw : "ASDFJKL";
                } else {
                    this.allowedKeys = "ASDFJKL";
                }

                this.updateHighscoreUI();
                this.initWorld();
                this.initPlayer();
                this.setupEvents();
                this.loop();
            }

            updateHighscoreUI() {
                const scoreHedy = localStorage.getItem('tastenZauber_bonusHighScore_Hedy') || 0;
                const scoreKeno = localStorage.getItem('tastenZauber_bonusHighScore_Keno') || 0;
                document.getElementById('hud-highscores').innerHTML = `üèÜ Hedy: ${scoreHedy} | üèÜ Keno: ${scoreKeno}`;
            }

            initWorld() {
                const count = 60000;
                const radius = 50; 
                const branches = 3;
                const spin = 1;
                const randomness = 0.2;
                const randomnessPower = 3;
                const coreColor = new THREE.Color('#ff8866');
                const outerColor = new THREE.Color('#4466ff');

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const scales = new Float32Array(count);
                const speeds = new Float32Array(count);

                for(let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const r = Math.random() * radius;
                    const spinAngle = r * spin;
                    const branchAngle = (i % branches) / branches * Math.PI * 2;
                    
                    const randomX = Math.pow(Math.random(), randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;
                    const randomY = Math.pow(Math.random(), randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;
                    const randomZ = Math.pow(Math.random(), randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;

                    positions[i3] = Math.cos(branchAngle + spinAngle) * r + randomX;
                    positions[i3+1] = randomY / 2;
                    positions[i3+2] = Math.sin(branchAngle + spinAngle) * r + randomZ;

                    const mixedColor = coreColor.clone();
                    mixedColor.lerp(outerColor, r / radius);
                    colors[i3] = mixedColor.r;
                    colors[i3+1] = mixedColor.g;
                    colors[i3+2] = mixedColor.b;

                    scales[i] = Math.random();
                    speeds[i] = (1.0 / (r + 0.5)) + (Math.random() - 0.5) * 0.1;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
                geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));

                this.galaxyMaterial = new THREE.ShaderMaterial({
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true,
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: 300.0 * this.renderer.getPixelRatio() } 
                    },
                    vertexShader: galaxyVertexShader,
                    fragmentShader: galaxyFragmentShader
                });

                this.galaxy = new THREE.Points(geometry, this.galaxyMaterial);
                this.galaxy.rotation.x = Math.PI / 3; 
                // Start further back
                this.galaxy.position.z = -150; 
                this.galaxy.position.y = -20;
                this.scene.add(this.galaxy);
            }

            initPlayer() {
                this.player = new THREE.Group(); 
                const hull = new THREE.Mesh(new THREE.ConeGeometry(1.5, 6, 8), new THREE.MeshBasicMaterial({color: 0x444444})); 
                hull.rotation.x = Math.PI/2; hull.rotation.z = Math.PI; this.player.add(hull);
                const cock = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({color: 0x00f3ff}));
                cock.position.set(0,0.5,1); this.player.add(cock);

                this.lvl2Group = new THREE.Group();
                const wing = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 2), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                wing.position.z = 1; this.lvl2Group.add(wing);
                this.lvl2Group.visible = false; this.player.add(this.lvl2Group);

                this.lvl3Group = new THREE.Group();
                const canL = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 4), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                canL.position.set(-3.5, 0, 0);
                const canR = canL.clone(); canR.position.set(3.5, 0, 0);
                this.lvl3Group.add(canL, canR);
                this.lvl3Group.visible = false; this.player.add(this.lvl3Group);

                this.player.position.set(0, -3, 18);
                this.scene.add(this.player);
            }

            getFingerColor(char) {
                const c = char.toUpperCase();
                if ('QAZ'.includes(c)) return '#ff3333';
                if ('WSX'.includes(c)) return '#ff9933';
                if ('EDC'.includes(c)) return '#ffff33';
                if ('RFVTGB'.includes(c)) return '#33ff33';
                if ('YHNUJM'.includes(c)) return '#3399ff';
                if ('IK'.includes(c)) return '#aa33ff';
                if ('OL'.includes(c)) return '#ff33cc';
                if ('P'.includes(c)) return '#ff33ff';
                return '#ffffff';
            }

            createEnemy() {
                let char = this.allowedKeys[Math.floor(Math.random() * this.allowedKeys.length)];
                let type = 'single';
                if (this.score > 1000 && Math.random() > 0.7) type = 'double';
                if (this.score > 3000 && Math.random() > 0.8) type = 'triple';

                let displayStr = char; let hp = 1; let sizeScale = 1;
                if (type === 'double') { displayStr = char+char; hp = 2; sizeScale = 1.5; }
                if (type === 'triple') { displayStr = char+char+char; hp = 3; sizeScale = 2.0; }

                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                const baseColor = this.getFingerColor(char);
                
                // FIX: Make letters brighter by using solid color instead of gradient to black
                ctx.fillStyle = baseColor; 
                ctx.fillRect(0,0,256,256);
                
                ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 15; ctx.strokeRect(0,0,256,256);
                ctx.fillStyle = '#ffffff'; ctx.font = "bold 100px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(displayStr, 128, 128);

                const mat = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 0.9 });
                const geo = new THREE.BoxGeometry(2.5 * sizeScale, 2.5 * sizeScale, 2.5 * sizeScale);
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.set((Math.random()-0.5)*30, (Math.random()-0.5)*12, -80);
                this.scene.add(mesh);
                return { mesh, char: char.toLowerCase(), hp, maxHp: hp, type, color: new THREE.Color(baseColor) };
            }

            createLaser(targetVec, colorHex) {
                const points = [ new THREE.Vector3(this.player.position.x, this.player.position.y, this.player.position.z-1), targetVec ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: colorHex, linewidth: 5 });
                const line = new THREE.Line(geometry, material);
                this.scene.add(line);
                setTimeout(() => this.scene.remove(line), 60);
            }

            createMassiveExplosion(pos, color) {
                this.shakeIntensity = 2.0; 
                this.audio.playMassiveExplosion();
                
                const geo = new THREE.RingGeometry(0.1, 0.5, 32);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true });
                const ring = new THREE.Mesh(geo, mat);
                ring.position.copy(pos);
                ring.lookAt(this.camera.position);
                this.scene.add(ring);
                this.shockwaves.push({ mesh: ring, scale: 1, opacity: 1 });

                for(let i=0; i<30; i++) {
                     const pGeo = new THREE.BoxGeometry(0.2,0.2,0.2);
                     const pMat = new THREE.MeshBasicMaterial({color: Math.random()>0.5?0xff00ff:0xffff00});
                     const p = new THREE.Mesh(pGeo, pMat);
                     p.position.copy(pos);
                     p.vel = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
                     this.scene.add(p);
                     this.particles.push({ mesh: p, life: 1.0 });
                }
            }

            loop() {
                requestAnimationFrame(() => this.loop());
                
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                // 1. ANIMATE GALAXY (DEEPER FLYTHROUGH)
                if(this.galaxyMaterial && this.galaxy) {
                    let spinSpeed = 0.2;
                    if(time > 60) spinSpeed = 2.0; 
                    this.galaxyMaterial.uniforms.uTime.value = time * spinSpeed;

                    // Fly from -150 to +100 over 60s (Camera is at +25)
                    if(time < 60) {
                        this.galaxy.position.z = -150 + (time / 60) * 250; 
                    } else {
                        this.galaxy.position.z = 100;
                    }
                }
                
                // 2. Camera Shake
                if (this.shakeIntensity > 0) {
                    const rx = (Math.random() - 0.5) * this.shakeIntensity;
                    const ry = (Math.random() - 0.5) * this.shakeIntensity;
                    this.camera.position.set(rx, 3 + ry, 25);
                    this.shakeIntensity -= 0.05;
                    if(this.shakeIntensity < 0) {
                        this.shakeIntensity = 0;
                        this.camera.position.set(0, 3, 25);
                    }
                }

                this.renderer.render(this.scene, this.camera);

                if(this.state !== 'PLAYING') return;

                this.player.rotation.z = Math.PI + Math.sin(time * 2) * 0.05;
                this.player.rotation.x = Math.sin(time * 1.5) * 0.05;

                if (time * 1000 - this.lastSpawn > this.spawnRate) {
                    this.enemies.push(this.createEnemy());
                    this.lastSpawn = time * 1000;
                    if (this.spawnRate > 600) this.spawnRate -= 10;
                    this.gameSpeed += 0.02;
                }

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    e.mesh.position.z += this.gameSpeed * delta;
                    e.mesh.rotation.x += delta;
                    e.mesh.rotation.y += delta;

                    if (e.mesh.position.z > 20) {
                        this.scene.remove(e.mesh);
                        this.enemies.splice(i, 1);
                        this.takeDamage();
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= delta * 1.5;
                    if(p.mesh && p.mesh.material) {
                         p.mesh.position.add(p.mesh.vel);
                         p.mesh.material.opacity = p.life;
                         if (p.life <= 0) {
                             this.scene.remove(p.mesh);
                             this.particles.splice(i, 1);
                         }
                    }
                }

                for (let i = this.shockwaves.length - 1; i >= 0; i--) {
                    const s = this.shockwaves[i];
                    s.scale += delta * 30;
                    s.opacity -= delta * 2;
                    s.mesh.scale.set(s.scale, s.scale, 1);
                    s.mesh.material.opacity = s.opacity;
                    if(s.opacity <= 0) {
                        this.scene.remove(s.mesh);
                        this.shockwaves.splice(i, 1);
                    }
                }
            }

            takeDamage() {
                this.lives--;
                let s = ""; for(let i=0; i<this.lives; i++) s += "‚ù§Ô∏è"; document.getElementById('hud-lives').innerText = s;
                this.audio.playLifeLost();
                this.shakeIntensity = 1.5; 
                this.combo = 0; document.getElementById('combo-bar').style.width = "0%";
                if (this.lives <= 0) this.gameOver();
            }

            heal() { if(this.lives < 5) { this.lives++; let s = ""; for(let i=0; i<this.lives; i++) s += "‚ù§Ô∏è"; document.getElementById('hud-lives').innerText = s; } }

            handleInput(key) {
                if(this.state !== 'PLAYING') return;
                let targetIdx = -1;
                let maxZ = -Infinity;

                for(let i=0; i<this.enemies.length; i++) {
                    if(this.enemies[i].char === key.toLowerCase()) {
                        if(this.enemies[i].mesh.position.z > maxZ) {
                            maxZ = this.enemies[i].mesh.position.z;
                            targetIdx = i;
                        }
                    }
                }

                if (targetIdx !== -1) {
                    const e = this.enemies[targetIdx];
                    let laserCol = 0xffff00;
                    if(this.weaponLevel === 2) laserCol = 0x00f3ff;
                    if(this.weaponLevel === 3) laserCol = 0xff00ff;

                    this.createLaser(e.mesh.position, laserCol);
                    this.audio.playShoot(this.weaponLevel);
                    e.hp--;
                    
                    if(e.hp <= 0) {
                        this.createMassiveExplosion(e.mesh.position, e.color);
                        this.scene.remove(e.mesh);
                        this.enemies.splice(targetIdx, 1);
                        this.combo++;
                        this.addScore(100 * this.weaponLevel * (e.maxHp)); 
                    } else {
                        e.mesh.scale.multiplyScalar(0.9);
                        e.mesh.material.color.setHex(0xffffff);
                        setTimeout(() => e.mesh.material.color.copy(e.color), 50);
                    }
                    document.getElementById('combo-bar').style.width = Math.min(this.combo * 4, 100) + "%";
                    if(this.combo > 1) { document.getElementById('combo-text').style.opacity = 1; document.getElementById('combo-text').innerText = "COMBO x" + this.combo; }
                    
                    this.hits++;
                    if(this.hits % 3 === 0) this.gameSpeed += 2; 

                } else {
                    this.takeDamage();
                }
            }

            addScore(pts) {
                this.score += pts + (this.combo * 10);
                document.getElementById('hud-score').innerText = this.score;
                if(this.score >= 2000 && this.weaponLevel === 1) this.upgradeWeapon(2, "PLASMA BLASTER", 0x00f3ff);
                if(this.score >= 5000 && this.weaponLevel === 2) this.upgradeWeapon(3, "PHOTON CANNON", 0xff00ff);
            }

            upgradeWeapon(lvl, name, color) {
                this.weaponLevel = lvl; this.audio.playPowerUp(); this.heal(); 
                document.getElementById('hud-weapon').innerText = name;
                document.getElementById('hud-weapon').style.borderColor = "#" + color.toString(16);
                const notif = document.getElementById('upgrade-notif');
                notif.innerText = name + " ACQUIRED!"; notif.style.color = "#" + color.toString(16);
                notif.style.opacity = 1; notif.style.transform = "translateX(-50%) scale(1.2)";
                setTimeout(() => { notif.style.opacity = 0; notif.style.transform = "translateX(-50%) scale(1)"; }, 3000);
                if(lvl === 2) this.lvl2Group.visible = true;
                if(lvl === 3) this.lvl3Group.visible = true;
            }

            setupEvents() {
                window.addEventListener('resize', () => { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); });
                window.addEventListener('keydown', (e) => {
                    if (e.key === "Escape") this.togglePause();
                    else if (this.state === 'PLAYING') {
                        const k = e.key.toUpperCase();
                        if (this.allowedKeys.includes(k) && !e.repeat) this.handleInput(k);
                    }
                });

                document.getElementById('btn-start').addEventListener('click', () => {
                    this.audio.resume();
                    this.startGame();
                });
                document.getElementById('btn-resume').addEventListener('click', () => this.togglePause());

                const goBack = () => {
                    const currentUser = this.currentUser;
                    const currentHigh = parseInt(localStorage.getItem(`tastenZauber_bonusHighScore_${currentUser}`) || 0);
                    if (this.score > currentHigh) {
                        localStorage.setItem(`tastenZauber_bonusHighScore_${currentUser}`, this.score);
                    }
                    
                    localStorage.setItem('tastenZauber_returning', 'true');
                    window.location.href = 'index.html';
                };
                
                document.getElementById('btn-quit').addEventListener('click', goBack);
                document.getElementById('btn-return').addEventListener('click', goBack);
                document.getElementById('btn-return-main').addEventListener('click', goBack);
            }

            togglePause() {
                if(this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    document.getElementById('pause-screen').classList.remove('hidden');
                    this.clock.stop();
                    this.audio.bgmEl.pause();
                } else if (this.state === 'PAUSED') {
                    this.state = 'PLAYING';
                    document.getElementById('pause-screen').classList.add('hidden');
                    this.clock.start();
                    this.audio.bgmEl.play();
                }
            }

            startGame() {
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('gameover-screen').classList.add('hidden');
                this.state = 'PLAYING';
                this.score = 0;
                this.lives = 3;
                this.combo = 0;
                this.weaponLevel = 1;
                
                this.enemies.forEach(e => this.scene.remove(e.mesh));
                this.enemies = [];
                this.particles.forEach(p => this.scene.remove(p.mesh));
                this.particles = [];
                this.shockwaves.forEach(s => this.scene.remove(s.mesh));
                this.shockwaves = [];

                this.lvl2Group.visible = false;
                this.lvl3Group.visible = false;
                document.getElementById('hud-weapon').innerText = "LASER MK-1";
                document.getElementById('hud-lives').innerText = "‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è";
                document.getElementById('hud-score').innerText = "0";
                
                this.clock.start();
                this.audio.startMusic();
            }

            gameOver() {
                this.state = 'GAMEOVER';
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score-disp').innerText = "Final Score: " + this.score;
                this.audio.stopMusic();
                this.audio.playLifeLost();

                // Save Highscore for current user
                const currentUser = this.currentUser;
                const currentHigh = parseInt(localStorage.getItem(`tastenZauber_bonusHighScore_${currentUser}`) || 0);
                if (this.score > currentHigh) {
                    localStorage.setItem(`tastenZauber_bonusHighScore_${currentUser}`, this.score);
                }
                // Update UI immediately to show new score
                this.updateHighscoreUI();
            }
        }

        window.onload = () => new Game();
    </script>
</body>
</html>
